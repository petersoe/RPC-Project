/** \mainpage 
\section Intro Intro
Elliott's auto generated documentation from inline comments for his rpc project. I used rpcgen for my project on solaris.

Trying to get rpcgen to run and have its autogenerated code compile correctly was very difficult on its own. I would not reccomend rpcgen to anyone. It seems wholly outdated and is very difficult to get operational.
I tried downloading many different packages and depricated versions of everything to get in work on Windows or Ubuntu. However, I simply couldn't accomplish it.
I eventually started to use different operating systems. It took a while to finally get one that worked, which was solaris.
It then took even longer to debug why the programs weren't working across my local virtual network. I had to sift through very granular logs to eventually determine the issue, 
which was an extremely obscure setting deep within solaris.

\section ClientSide Client Side Code
My client side has a thread to constantly listen for incoming UDP publications from the server. It saves the received articles to the disk, 
and it then sends out a UDP verification to the server that it received the article.

My client updates upon launching of the client or after a server connection is re-established automatically after being dropped (e.g. server 
goes down).

The client uses port 54321 to listen for publications on. The client only receives UDP messages from the server address given. 

The server IP, server port, and listening port on the client are permanently set within the code, but the lines of code to allow for command-line entering
can be uncommented. The client confirms a server-port combination is acceptable with an initial ping. If the combination does not work, the code
continues to loop trying to access the server. Since by default the server information is permanent in the code, you will have to force exit the executable 
if the server information is not correct or the server is not active upon initialization of the client.

My client uses the first non-loopback IP for the client for the automatic update upon starting, but a manual update or command can be done with any IP and valid (within unsigned short range) port. 

Type help in the command line to see a list of RPC calls and the test program call.

Mutual exclusion locks are in place to prevent any race conditions that might occur. Publications should not arrive out of order, because
verifications are waited for on the server side before sending out another publication. 

For debugging of the rpc, full description of why a call returned a failure after a successful call is not given by the server to the client. That information is logged on the server-side.

If a server connection fails while the client application is active, the client application locks down any further manual commands. It then attempts to recreate 
the connections and ping the server every 3 seconds. If the connection is re-established, the client is immediately updated and then continues to listen and save new publications.
The client will not unlock manual commands again. You must restart the client application to do that. There is an unknown memory problem with my code that causes the client to crash
if I unlock calls outside the ping thread after the connection is re-established.

The full doxy documentation generated from inline comments for the client side code before rpcgen can be found here: communicate_client.c

\section ServerSide Server Side Code
All client, subscription, and failed send information is kept in memory, but saved to the disk upon any changes. The disk is only read from during initialization.

Mutual exclusion locks are in place to prevent any race condition I could think of from occurring. Rpcgen does not allow for concurrent RPC calls,
so not many mutual exclusion locks were necessary. No messages sent or received care about order they are in. 
The mutual exclusion locks were just for the multithreading I utilized for listening for verifications from clients.

Full logging of all calls, why functions failed or were rejected, and various other important debugging information is kept in server.log. No time information is kept. Just delete everything in the log and rerun to observe what is happening.

Full logging of the verifications received and when the timeout is reached while waiting for more clients to verify is reached is saved within verification.log. This prevents race conditions as it runs on another thread, and it keeps things clearer in server.log.

Clients that have joined a server are stored in memory in simple char array.

Subscriptions are kept in pubSub structures. These structures also contain an address structure. Both the address and full object have a hash of the object, but I did not complete the hashmap to optimize searches.

All articles must match requirements for publications and subscriptions. Publications are only sent out to clients that both meet the subscription data and are actively joined.

Within articles a blank space is assumed to be a wildcard. Only one article is to each client even if the client has multiple subscriptions that meet the requirements.
More general subscriptions (i.e. subscriptions that include everything a more restrictive subscription has) supersede more specific subscriptions in determining if an article is sent.


The full doxy documentation generated from inline comments for the server side code before rpcgen can be found here: communicate_server.c

The server code heavily utilizes code from a secondary file I made primarily focused on pubSub objects and clientData array: pubSubTools.c && pubSubTools.h
*/